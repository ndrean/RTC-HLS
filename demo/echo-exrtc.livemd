# Echo with ExRTC

```elixir
Mix.install([
  {:kino, "~> 0.13.1"},
  {:ex_webrtc, "~> 0.3.0"}
])
```

## Section

```elixir
defmodule ExRtcServer do
  use GenServer

  alias ExWebRTC.{ICECandidate, PeerConnection, SessionDescription, MediaStreamTrack}
  #alias ExWebRTC.RTP.VP8Depayloader

  require Logger

  defp ice_servers(), do: [%{urls: "stun:stun.l.google.com:19302"}]

  defp setup_transceivers(pc) do
    video_track = MediaStreamTrack.new(:video)
    {:ok, _sender} = PeerConnection.add_track(pc, video_track)
    %{serv_video_track: video_track}
  end

  def start_link(args), do: GenServer.start_link(__MODULE__, args, name: __MODULE__)
  def connect, do: GenServer.call(__MODULE__, :connect)

  def receive_signaling_msg({msg, sender}) do
    GenServer.cast(__MODULE__, {:receive_signaling_msg, msg, sender})
  end


  def peek_state, do: GenServer.call(__MODULE__, :peek_state)

  @impl true
  def init(_args) do
    Logger.info("ExRtcPeerConnection started")
    {:ok, %{
      sender: nil,
      pc: nil,
      client_video_track: nil,
      #video_deplayloader: VP8Depayloader.new()
    }}
  end

  # callbacks on client messages -----
  @impl true
  def handle_call(:peek_state, _, state) do
    {:reply, state, state}
  end

  def handle_call(:connect, _, state) do
    {:ok, pc_pid} = PeerConnection.start_link(ice_servers: ice_servers())

    state = %{state | pc: pc_pid} |> Map.merge(setup_transceivers(pc_pid))
    {:reply, :connected, state}
  end

  @impl true
  def handle_cast({:receive_signaling_msg, %{"type"=> "offer"} = msg, sender},state) do
    with desc <-
           SessionDescription.from_json(msg),
         :ok <-
           PeerConnection.set_remote_description(state.pc, desc),
         {:ok, answer} <-
           PeerConnection.create_answer(state.pc),
         :ok <-
           PeerConnection.set_local_description(state.pc, answer),
         :ok <-
           gather_candidates(state.pc) do
      Logger.warning("--> Server sends Answer to remote")

      #  the 'answer' is formatted into a struct, which can't be read by the JS client
      answer = %{"type" =>  "answer", "sdp" => answer.sdp}


      send(sender, {:signaling, answer})
      {:noreply, %{state | sender: sender}}
    else
      error ->
        Logger.error("Server: Error creating answer: #{inspect(error)}")
        {:stop, :shutdown, state}
    end
  end

  def handle_cast({:receive_signaling_msg, %{"type"=> "ice"} = msg, _sender}, state) do
    case msg do
      nil ->
        {:noreply, state}

      candidate ->
        candidate = ICECandidate.from_json(candidate)
        :ok = PeerConnection.add_ice_candidate(state.pc, candidate)
        Logger.debug("--> Server processes remote ICE")
        {:noreply, state}
    end
  end

  def handle_cast({:receive_signaling_msg, {msg, _}}, state) do
    Logger.warning("Server: unexpected msg: #{inspect(msg)}")
    {:stop, :shutdown, state}
  end

  @impl true
  def handle_info({:ex_webrtc, _pc, {:track, %{kind: :video} = client_video_track}}, state) do
    {:noreply, %{state | client_video_track: client_video_track}}
  end

  # callbacks on process messages --------
  def handle_info({:ex_webrtc, _pc, {:ice_candidate, candidate}}, state) do
    candidate = ICECandidate.to_json(candidate)
    send(state.sender, {:signaling, %{"type"=> "ice", "candidate" => candidate}})
    Logger.debug("--> Server sends ICE to remote")
    {:noreply, state}
  end

  def handle_info(
        {:ex_webrtc, pc, {:rtp, client_track_id, packet}},
        %{client_video_track: %{id: client_track_id, kind: :video}} = state
      ) do
    PeerConnection.send_rtp(pc, state.serv_video_track.id, packet)
    {:noreply, state}
  end

  def handle_info({:ex_webrtc, pc, {:connection_state_change, :connected}}, state) do
    sdp = PeerConnection.get_remote_description(pc).sdp
    Regex.scan(~r/a=rtpmap:([a-zA-Z0-9\s]+)/, sdp) |> dbg()

    Logger.warning("Server to client PeerConnection #{inspect(pc)} successfully connected")
    {:noreply, state}
  end

  def handle_info({:ex_webrtc, _pc, _msg}, state) do
    {:noreply, state}
  end

  defp gather_candidates(pc) do
    receive do
      {:ex_webrtc, ^pc, {:ice_gathering_state_change, :complete}} -> :ok
    after
      1000 -> {:error, :timeout}
    end
  end
end
```

```elixir
Supervisor.start_link([ExRtcServer], strategy: :one_for_one, name: MySup)
```

```elixir
ExRtcServer.connect()
```

```elixir
ExRtcServer.peek_state()
```

```elixir
defmodule VideoLive do

  use Kino.JS
  use Kino.JS.Live

  require Logger

  @html """
    <div id="elt">
      <video id="videoIn" width="400" height="400" controls muted playsinline autoplay></video>
      <button type="button" id="stop" phx-click="stop">Stop streaming</button>
      <video id="echo" width="400" height="400" controls muted playsinline autoplay></video>
    </div>
    """

  def new() do
    Kino.JS.Live.new(__MODULE__, @html)
  end

  asset "main.css" do
    """
    #elt {
      display: flex;
      flex-direction: column;
      align-items: center
    }
    button {
      margin-top: 1em;
      margin-bottom: 1em;
      padding: 1em;
      background-color: bisque;
    }
    """
  end

  asset "main.js" do
    """
    export function init(ctx, html) {
      ctx.importCSS("main.css");
      ctx.root.innerHTML = html;

      const iceConf = {
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      };

      function run() {
        window.navigator.mediaDevices
          .getUserMedia({ video: { width: 400, height: 400 }, audio: false })
          .then((stream) => {
            let videoIn = document.getElementById("videoIn"),
              send = true;

            document.getElementById("stop").onclick = () => {
              send = false;
              ctx.pushEvent("stop", {});
            };

            videoIn.srcObject = stream;

            const pc = new RTCPeerConnection(iceConf);
            const tracks = stream.getTracks();
            tracks.forEach((track) => pc.addTrack(track, stream));

            pc.onicecandidate = (evt) => {
              if (evt.candidate) {
                ctx.pushEvent("ice", { candidate: evt.candidate, type: "ice" });
              }
            };

            pc.ontrack = ({ streams }) => {
              console.log("--> Received remote track");
              const echo = document.querySelector("#echo");
              echo.srcObject = streams[0];
              echo.onloadeddata = () => echo.play();
            };

            pc.onnegotiationneeded = async () => {
              const offer = await pc.createOffer();
              await pc.setLocalDescription(offer);
              console.log("--> Offer created and sent", offer);
              ctx.pushEvent("offer", { sdp: offer});
            };

            pc.onconnectionstatechange = () => {
              console.log("~~> Connection state: ", pc.connectionState);
            };

            ctx.handleEvent("ice", async (msg) => {
              await pc.addIceCandidate(msg.candidate);
            });

            ctx.handleEvent("answer", async (msg) => {
              console.log("--> handled Answer");
              await pc.setRemoteDescription(msg);
            });
          });
      }
      run()
    }
    """
  end

  @impl true
  def init(html, ctx) do
    {:ok, assign(ctx, html: html)}
  end

  @impl true
  def handle_connect(ctx) do
    {:ok, ctx.assigns.html, ctx}
  end

  @impl true
  def handle_event("stop", _, ctx) do
    Logger.debug("Got stop")
    {:noreply, ctx}
  end

  def handle_event("offer",%{"sdp" => sdp}, ctx) do
    ExRtcServer.receive_signaling_msg({sdp, self()})
    {:noreply, ctx}
  end
  def handle_event("ice",%{"candidate" => candidate}, ctx) do
    ExRtcServer.receive_signaling_msg({candidate, self()})
    {:noreply, ctx}
  end

  @impl true

  def handle_info({:signaling, %{"type" => "answer"} = msg}, ctx) do
    broadcast_event(ctx, "answer", msg)
    {:noreply, ctx}
  end

  def handle_info({:signaling, %{"type" => "ice", "candidate" => _candidate} = msg}, ctx) do
    broadcast_event(ctx, "ice",msg)
    dbg(ctx)
    {:noreply, ctx}
  end

end
```

```elixir
VideoLive.new()
```
